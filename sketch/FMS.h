
#ifndef HFTE_FMS_H_
#define HFTE_FMS_H_

#include <cassert>
#include <cstdio>
#include <set>
#include <logging.h>

namespace HFTE
{
	typedef enum
	{
		ENGINE_STATE_NOSTATE,

		ENGINE_STATE_ENTER,

		ENGINE_STATE_LIMIT_SELL,
		ENGINE_STATE_TRADE_SELL,
		ENGINE_STATE_LIMIT_BUY_COVER,

		ENGINE_STATE_LIMIT_SELLBUY,

		ENGINE_STATE_LIMIT_BUY,
		ENGINE_STATE_TRADE_BUY,
		ENGINE_STATE_LIMIT_SELL_COVER,

		ENGINE_STATE_EXIT,

		ENGINE_STATES_COUNT
	} EngineState;

	inline const char *GetEngineStateString(EngineState state)
	{
		assert(state < ENGINE_STATES_COUNT);

		switch (state)
		{
		case ENGINE_STATE_NOSTATE: return "ENGINE_STATE_NOSTATE";
		case ENGINE_STATE_ENTER: return "ENGINE_STATE_ENTER";
		case ENGINE_STATE_LIMIT_SELL: return "ENGINE_STATE_LIMIT_SELL";
		case ENGINE_STATE_TRADE_SELL: return "ENGINE_STATE_TRADE_SELL";
		case ENGINE_STATE_LIMIT_BUY_COVER: return "ENGINE_STATE_LIMIT_BUY_COVER";
		case ENGINE_STATE_LIMIT_SELLBUY: return "ENGINE_STATE_LIMIT_SELLBUY";
		case ENGINE_STATE_LIMIT_BUY: return "ENGINE_STATE_LIMIT_BUY";
		case ENGINE_STATE_TRADE_BUY: return "ENGINE_STATE_TRADE_BUY";
		case ENGINE_STATE_LIMIT_SELL_COVER: return "ENGINE_STATE_LIMIT_SELL_COVER";
		case ENGINE_STATE_EXIT: return "ENGINE_STATE_EXIT";
		default: return "ENGINE_STATE_UNKNOWN";
		}
	}

	typedef enum
	{
		ENGINE_ACTION_NOACTION,

		ENGINE_ACTION_LIMIT_SELL_PLACE,
		ENGINE_ACTION_LIMIT_SELL_MOVE,
		ENGINE_ACTION_LIMIT_SELL_CANCEL,

		ENGINE_ACTION_LIMIT_BUY_PLACE,
		ENGINE_ACTION_LIMIT_BUY_MOVE,
		ENGINE_ACTION_LIMIT_BUY_CANCEL,

		ENGINE_ACTIONS_COUNT
	} EngineAction;

	inline const char *GetEngineActionString(EngineAction action)
	{
		assert(action < ENGINE_ACTIONS_COUNT);

		switch (action)
		{
		case ENGINE_ACTION_NOACTION: return "ENGINE_ACTION_NOACTION";
		case ENGINE_ACTION_LIMIT_SELL_PLACE: return "ENGINE_ACTION_LIMIT_SELL_PLACE";
		case ENGINE_ACTION_LIMIT_SELL_MOVE: return "ENGINE_ACTION_LIMIT_SELL_MOVE";
		case ENGINE_ACTION_LIMIT_SELL_CANCEL: return "ENGINE_ACTION_LIMIT_SELL_CANCEL";
		case ENGINE_ACTION_LIMIT_BUY_PLACE: return "ENGINE_ACTION_LIMIT_BUY_PLACE";
		case ENGINE_ACTION_LIMIT_BUY_MOVE: return "ENGINE_ACTION_LIMIT_BUY_MOVE";
		case ENGINE_ACTION_LIMIT_BUY_CANCEL: return "ENGINE_ACTION_LIMIT_BUY_CANCEL";
		default: return "ENGINE_ACTION_UNKNOWN";
		}
	}

	typedef enum
	{
		SYSTEM_ACTION_NOACTION,

		SYSTEM_ACTION_LIMIT_SELL_FILLED,

		SYSTEM_ACTION_LIMIT_SELL_PLACE_SUCCESS,
		SYSTEM_ACTION_LIMIT_SELL_PLACE_FAILED,

		SYSTEM_ACTION_LIMIT_SELL_MOVE_SUCCESS,
		SYSTEM_ACTION_LIMIT_SELL_MOVE_FAILED,

		SYSTEM_ACTION_LIMIT_SELL_CANCEL_SUCCESS,
		SYSTEM_ACTION_LIMIT_SELL_CANCEL_FAILED,
		
		SYSTEM_ACTION_LIMIT_BUY_CANCEL_SUCCESS,
		SYSTEM_ACTION_LIMIT_BUY_CANCEL_FAILED,

		SYSTEM_ACTION_LIMIT_BUY_MOVE_SUCCESS,
		SYSTEM_ACTION_LIMIT_BUY_MOVE_FAILED,

		SYSTEM_ACTION_LIMIT_BUY_PLACE_SUCCESS,
		SYSTEM_ACTION_LIMIT_BUY_PLACE_FAILED,

		SYSTEM_ACTION_LIMIT_BUY_FILLED,

		SYSTEM_ACTIONS_COUNT
	} SystemAction;

	inline const char *GetSystemActionString(SystemAction action)
	{
		assert(action < SYSTEM_ACTIONS_COUNT);

		switch (action)
		{
		case SYSTEM_ACTION_NOACTION: return "SYSTEM_ACTION_NOACTION";
		case SYSTEM_ACTION_LIMIT_SELL_FILLED: return "SYSTEM_ACTION_LIMIT_SELL_FILLED";
		case SYSTEM_ACTION_LIMIT_SELL_PLACE_SUCCESS: return "SYSTEM_ACTION_LIMIT_SELL_PLACE_SUCCESS";
		case SYSTEM_ACTION_LIMIT_SELL_PLACE_FAILED: return "SYSTEM_ACTION_LIMIT_SELL_PLACE_FAILED";
		case SYSTEM_ACTION_LIMIT_SELL_MOVE_SUCCESS: return "SYSTEM_ACTION_LIMIT_SELL_MOVE_SUCCESS";
		case SYSTEM_ACTION_LIMIT_SELL_MOVE_FAILED: return "SYSTEM_ACTION_LIMIT_SELL_MOVE_FAILED";
		case SYSTEM_ACTION_LIMIT_SELL_CANCEL_SUCCESS: return "SYSTEM_ACTION_LIMIT_SELL_CANCEL_SUCCESS";
		case SYSTEM_ACTION_LIMIT_SELL_CANCEL_FAILED: return "SYSTEM_ACTION_LIMIT_SELL_CANCEL_FAILED";
		case SYSTEM_ACTION_LIMIT_BUY_CANCEL_SUCCESS: return "SYSTEM_ACTION_LIMIT_BUY_CANCEL_SUCCESS";
		case SYSTEM_ACTION_LIMIT_BUY_CANCEL_FAILED: return "SYSTEM_ACTION_LIMIT_BUY_CANCEL_FAILED";
		case SYSTEM_ACTION_LIMIT_BUY_MOVE_SUCCESS: return "SYSTEM_ACTION_LIMIT_BUY_MOVE_SUCCESS";
		case SYSTEM_ACTION_LIMIT_BUY_MOVE_FAILED: return "SYSTEM_ACTION_LIMIT_BUY_MOVE_FAILED";
		case SYSTEM_ACTION_LIMIT_BUY_PLACE_SUCCESS: return "SYSTEM_ACTION_LIMIT_BUY_PLACE_SUCCESS";
		case SYSTEM_ACTION_LIMIT_BUY_PLACE_FAILED: return "SYSTEM_ACTION_LIMIT_BUY_PLACE_FAILED";
		case SYSTEM_ACTION_LIMIT_BUY_FILLED: return "SYSTEM_ACTION_LIMIT_BUY_FILLED";
		default: return "SYSTEM_ACTION_UNKNOWN";
		}
	}

	typedef enum
	{
		TRADE_POLICY_ONLY_SELL,
		TRADE_POLICY_ONLY_BUY,
		TRADE_POLICY_NO_BIDIRECTION,
		TRADE_POLICIES_COUNT
	} TradePolicy;

	inline const char *GetTradePolicyString(TradePolicy policy)
	{
		assert(policy < TRADE_POLICIES_COUNT);

		switch (policy)
		{
		case TRADE_POLICY_ONLY_SELL: return "TRADE_POLICY_ONLY_SELL";
		case TRADE_POLICY_ONLY_BUY: return "TRADE_POLICY_ONLY_BUY";
		case TRADE_POLICY_NO_BIDIRECTION: return "TRADE_POLICY_NO_BIDIRECTION";
		default: return "TRADE_POLICY_UNKNOWN";
		}
	}

	extern "C" EngineState engineStateTransitionsMatrix[ENGINE_STATES_COUNT][ENGINE_ACTIONS_COUNT][SYSTEM_ACTIONS_COUNT];
	extern "C" EngineAction engineActionFilterMatrix[ENGINE_STATES_COUNT][ENGINE_ACTIONS_COUNT][ENGINE_ACTIONS_COUNT];

	void InitFMSMatrices(std::set<TradePolicy> policies = {});
}

#endif /* HFTE_FMS_H_ */
